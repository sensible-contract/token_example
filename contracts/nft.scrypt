import "util.scrypt";
import "rabin.scrypt";
import "satotx.scrypt";

/*
 A safty NFT protocol

 locking script:

 issue:

   codePart, GenesisOutpoint, issuerPkh, tokenId, ISSUE

 transfer:

   codePart, GenesisOutpoint, ownerPkh, tokenId, TRANSFER


 issue 函数允许发行人按tokenId从0递增发行nft，输出为一个ISSUE，一个TRANSFER

 transfer 函数允许用户移动自己的nft，输出为一个TRANSFER，一个找零.

 burn 函数用于用户销毁自己的1个nft，输入为1个TRANSFER，输出为1个找零
*/


contract Payload {
  int dataStart;
  bytes codePart;

  bytes genesisOutpoint;
  Ripemd160 ownerPkh;
  int tokenId;
  bytes action;

  constructor(bytes scriptCode) {
    this.dataStart = len(scriptCode) - 65;
    this.codePart = scriptCode[ : this.dataStart];

    bytes dataPart = scriptCode[this.dataStart : ];

    this.genesisOutpoint = dataPart[:36];
    this.ownerPkh = Ripemd160(dataPart[36:36+20]);
    this.tokenId = unpack(dataPart[56:56+8]);
    this.action = dataPart[64:65];
  }

  function dump() : bytes {
    bytes payload = this.genesisOutpoint +
    this.ownerPkh +
    num2bin(this.tokenId, Util.OutputValueLen) +
    this.action;

    return this.codePart + payload;
  }
}


contract NFT {
  int rabinPubKey;

  static bytes ISSUE = b'00';
  static bytes TRANSFER = b'01';

  /* issue */
  public function issue(SigHashPreimage txPreimage,
    int preTxOutpointSig, bytes preTxOutpointMsg, bytes preTxOutpointPadding,
    Sig issuerSig, PubKey issuer,
    Ripemd160 receiverPkh, int satoshiAmount1,
    Ripemd160 changePkh, int satoshiAmount2) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    Payload pl = new Payload(lockingScript);

    // action must be issue
    require(pl.action == NFT.ISSUE);

    SatoTx st = new SatoTx(this.rabinPubKey, txPreimage, preTxOutpointSig, preTxOutpointMsg, preTxOutpointPadding, 0, b'', b'');
    require(st.verifyGenesis(lockingScript, pl.genesisOutpoint, pl.dataStart));

    // authorize
    require(hash160(issuer) == pl.ownerPkh);
    require(checkSig(issuerSig, issuer));

    // 业务操作
    int satoshiIssue = Util.value(txPreimage);

    pl.tokenId = pl.tokenId + 1;
    bytes outputScript0 = pl.dump();
    bytes output0 = Util.buildOutput(outputScript0, satoshiIssue);

    pl.ownerPkh = receiverPkh;
    pl.action = NFT.TRANSFER;
    bytes outputScript1 = pl.dump();
    bytes output1 = Util.buildOutput(outputScript1, satoshiAmount1);

    bytes lockingScript2 = Util.buildPublicKeyHashScript(changePkh);
    bytes output2 = Util.buildOutput(lockingScript2, satoshiAmount2);

    Sha256 hashOutputs = hash256(output0 + output1 + output2);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }

  /* transfer */
  public function transfer(SigHashPreimage txPreimage,
    int preTxOutpointSig, bytes preTxOutpointMsg, bytes preTxOutpointPadding,

    Sig senderSig, PubKey sender,
    Ripemd160 receiverPkh, int satoshiAmount0,
    Ripemd160 changePkh, int satoshiAmount1) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    Payload pl = new Payload(lockingScript);

    // action must be transfer
    require(pl.action == NFT.TRANSFER);

    // 溯源
    SatoTx st = new SatoTx(this.rabinPubKey, txPreimage, preTxOutpointSig, preTxOutpointMsg, preTxOutpointPadding, 0, b'', b'');
    require(st.verifyGenesis(lockingScript, SatoTx.disableUtxoInGenesisTx, pl.dataStart));

    // authorize
    require(hash160(sender) == pl.ownerPkh);
    require(checkSig(senderSig, sender));

    // 业务操作
    pl.ownerPkh = receiverPkh;
    bytes outputScript0 = pl.dump();
    bytes output0 = Util.buildOutput(outputScript0, satoshiAmount0);

    bytes lockingScript1 = Util.buildPublicKeyHashScript(changePkh);
    bytes output1 = Util.buildOutput(lockingScript1, satoshiAmount1);

    Sha256 hashOutputs = hash256(output0 + output1);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }

  // burn a token back to normal bitcoins
  public function burn(SigHashPreimage txPreimage,
    Sig ownerSig, PubKey owner,
    Ripemd160 receiverPkh, int satoshiAmount) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    Payload pl = new Payload(lockingScript);

    // action must be transfer
    require(pl.action == NFT.TRANSFER);

    // authorize
    require(hash160(owner) == pl.ownerPkh);
    require(checkSig(ownerSig, owner));

    // send to a P2PKH script
    bytes lockingScript0 = Util.buildPublicKeyHashScript(receiverPkh);
    bytes output0 = Util.buildOutput(lockingScript0, satoshiAmount);
    Sha256 hashOutputs = hash256(output0);
    require(hashOutputs == Util.hashOutputs(txPreimage));  }}
