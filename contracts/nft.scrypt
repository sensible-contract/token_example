import "util.scrypt";
import "rabin.scrypt";
import "satotx.scrypt";

/*
* A safty NFT protocol
*
* locking script:
*
* issue:
*
*   codePart, GenesisOutpoint, issuerPkh, tokenId, ISSUE
*
* transfer:
*
*   codePart, GenesisOutpoint, ownerPkh, tokenId, TRANSFER
*
*
* issue 函数允许发行人按tokenId从0递增发行nft，输出为一个ISSUE，一个TRANSFER
*
* transfer 函数允许用户移动自己的nft，输出为一个TRANSFER，一个找零.
*
* burn 函数用于用户销毁自己的1个nft，输入为1个TRANSFER，输出为1个找零
*/

contract Payload {
  int dataStart;
  bytes codePart;

  bytes genesisOutpoint;
  bytes genesisOutputIdx;
  Ripemd160 ownerPkh;
  int tokenId;
  bytes dataType;

  constructor(bytes scriptCode) {
    this.dataStart = len(scriptCode) - 69;
    this.codePart = scriptCode[ : this.dataStart];

    bytes dataPart = scriptCode[this.dataStart : ];

    /* 溯源需匹配genesisTx input的outpoint 和output的index */
    this.genesisOutpoint = dataPart[ : 36];
    this.genesisOutputIdx = dataPart[36 : 36 + 4];

    this.ownerPkh = Ripemd160(dataPart[40 : 40 + 20]);
    this.tokenId = unpack(dataPart[60 : 60 + 8]);
    this.dataType = dataPart[68 : 69];
  }

  function dump() : bytes {
    bytes payload = this.genesisOutpoint + this.genesisOutputIdx +
    this.ownerPkh +
    num2bin(this.tokenId, Util.OutputValueLen) +
    this.dataType;

    return this.codePart + payload;
  }
}

contract NFT {
  int rabinPubKey;

  static bytes ISSUE = b'00';
  static bytes TRANSFER = b'01';

  /* issue */
  public function issue(SigHashPreimage txPreimage,
    int preTxOutpointSig, bytes preTxOutpointMsg, bytes preTxOutpointPadding,
    Sig issuerSig, PubKey issuer,
    Ripemd160 receiverPkh, int satoshiAmount1,
    Ripemd160 changePkh, int satoshiAmount2) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    Payload pl = new Payload(lockingScript);

    // dataType must be issue
    require(pl.dataType == NFT.ISSUE);

    SatoTx st = new SatoTx(this.rabinPubKey, txPreimage, preTxOutpointSig, preTxOutpointMsg, preTxOutpointPadding, 0, b'', b'');
    require(st.verifyGenesis(lockingScript, pl.genesisOutpoint, pl.genesisOutputIdx, pl.dataStart));

    // authorize
    require(hash160(issuer) == pl.ownerPkh);
    require(checkSig(issuerSig, issuer));

    // 业务操作
    int satoshiIssue = Util.value(txPreimage);

    pl.tokenId = pl.tokenId + 1;
    bytes outputScript0 = pl.dump();
    bytes output0 = Util.buildOutput(outputScript0, satoshiIssue);

    pl.ownerPkh = receiverPkh;
    pl.dataType = NFT.TRANSFER;
    bytes outputScript1 = pl.dump();
    bytes output1 = Util.buildOutput(outputScript1, satoshiAmount1);

    bytes lockingScript2 = Util.buildPublicKeyHashScript(changePkh);
    bytes output2 = Util.buildOutput(lockingScript2, satoshiAmount2);

    Sha256 hashOutputs = hash256(output0 + output1 + output2);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }

  /* transfer */
  public function transfer(SigHashPreimage txPreimage,
    int preTxOutpointSig, bytes preTxOutpointMsg, bytes preTxOutpointPadding,

    Sig senderSig, PubKey sender,
    Ripemd160 receiverPkh, int satoshiAmount0,
    Ripemd160 changePkh, int satoshiAmount1) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    Payload pl = new Payload(lockingScript);

    // dataType must be transfer
    require(pl.dataType == NFT.TRANSFER);

    // 溯源
    SatoTx st = new SatoTx(this.rabinPubKey, txPreimage, preTxOutpointSig, preTxOutpointMsg, preTxOutpointPadding, 0, b'', b'');
    require(st.verifyGenesis(lockingScript, SatoTx.disableUtxoInGenesisTx, b'', pl.dataStart));

    // authorize
    require(hash160(sender) == pl.ownerPkh);
    require(checkSig(senderSig, sender));

    // 业务操作
    pl.ownerPkh = receiverPkh;
    bytes outputScript0 = pl.dump();
    bytes output0 = Util.buildOutput(outputScript0, satoshiAmount0);

    bytes lockingScript1 = Util.buildPublicKeyHashScript(changePkh);
    bytes output1 = Util.buildOutput(lockingScript1, satoshiAmount1);

    Sha256 hashOutputs = hash256(output0 + output1);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }

  // burn a token back to normal bitcoins
  public function burn(SigHashPreimage txPreimage,
    Sig ownerSig, PubKey owner,
    Ripemd160 receiverPkh, int satoshiAmount) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    Payload pl = new Payload(lockingScript);

    // dataType must be transfer
    require(pl.dataType == NFT.TRANSFER);

    // authorize
    require(hash160(owner) == pl.ownerPkh);
    require(checkSig(ownerSig, owner));

    // send to a P2PKH script
    bytes lockingScript0 = Util.buildPublicKeyHashScript(receiverPkh);
    bytes output0 = Util.buildOutput(lockingScript0, satoshiAmount);
    Sha256 hashOutputs = hash256(output0);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }
}
