import "util.scrypt";
import "rabin.scrypt";
import "satotx.scrypt";
import "payload_nft.scrypt";

/*
* A safty NFT protocol
*
*
* issue:
*   codePart, GenesisPart, issuerPkh, tokenId, ISSUE
*    ->
*   codePart, GenesisPart, issuerPkh, tokenId+1, ISSUE
*   codePart, GenesisPart, ownerPkh, tokenId+1, TRANSFER
*
* transfer:
*   codePart, GenesisPart, ownerPkhA, tokenId, TRANSFER
*    ->
*   codePart, GenesisPart, ownerPkhB, tokenId, TRANSFER
*
*
* makeSwap:
*   codePartA, GenesisPartA, ownerPkhA, tokenId, TRANSFER
*    ->
*   codePartA, GenesisPartA, ownerPkhA, tokenId, hash256(codePartB + GenesisPartB), tokenAmountB, SWAP
*
* takeSwap:
*   codePartA, GenesisPartA, ownerPkhA, tokenId, hash256(codePartB + GenesisPartB), tokenAmountB, SWAP
*   codePartB, GenesisPartB, ownerPkhB, tokenAmountB, TRANSFER
*    ->
*   codePartA, GenesisPartA, ownerPkhB, tokenId, TRANSFER
*   codePartB, GenesisPartB, ownerPkhA, tokenAmountB, TRANSFER
*
*
* sell:
*   codePart, GenesisPart, ownerPkhA, tokenId, TRANSFER
*    ->
*   codePart, GenesisPart, ownerPkhA, tokenId, satoshiAmount, SELL
*
* buy:
*   codePart, GenesisPart, ownerPkhA, tokenId, satoshiAmount, SELL
*   ownerPkhB, satoshiAmount
*    ->
*   codePart, GenesisPart, ownerPkhB, tokenId, TRANSFER
*   ownerPkhA, satoshiAmount
*
* issue 函数允许发行人按tokenId从0递增发行nft，输出为一个ISSUE，一个TRANSFER
*
* transfer 函数允许用户移动自己的nft，输出为一个TRANSFER，一个找零.
*
* burn 函数用于用户销毁自己的1个nft，输入为1个TRANSFER，输出为1个找零
*/


contract NFT {
  int rabinPubKey;

  //////////////// issue
  public function issue(SigHashPreimage txPreimage,
    int preTxOutpointSig, bytes preTxOutpointMsg, bytes preTxOutpointPadding,
    Sig issuerSig, PubKey issuer,
    Ripemd160 receiverPkh, int satoshiAmount1,
    Ripemd160 changePkh, int satoshiAmount2) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    PayloadNFT pl = new PayloadNFT(lockingScript);

    // dataType must be issue
    require(pl.dataType == PayloadNFT.ISSUE);

    SatoTx st = new SatoTx(this.rabinPubKey, txPreimage, preTxOutpointSig, preTxOutpointMsg, preTxOutpointPadding, 0, b'', b'');
    require(st.verifyGenesis(pl.codeWithGenesisPart, pl.genesisOutpoint, pl.genesisOutputIdx));

    // authorize
    require(hash160(issuer) == pl.ownerPkh);
    require(checkSig(issuerSig, issuer));

    // 业务操作
    int satoshiIssue = Util.value(txPreimage);

    pl.tokenId = pl.tokenId + 1;
    bytes outputScript0 = pl.dump();
    bytes output0 = Util.buildOutput(outputScript0, satoshiIssue);

    pl.ownerPkh = receiverPkh;
    pl.dataType = PayloadNFT.TRANSFER;
    bytes outputScript1 = pl.dump();
    bytes output1 = Util.buildOutput(outputScript1, satoshiAmount1);

    bytes lockingScript2 = Util.buildPublicKeyHashScript(changePkh);
    bytes output2 = Util.buildOutput(lockingScript2, satoshiAmount2);

    Sha256 hashOutputs = hash256(output0 + output1 + output2);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }

  //////////////// transfer
  public function transfer(SigHashPreimage txPreimage,
    int preTxOutpointSig, bytes preTxOutpointMsg, bytes preTxOutpointPadding,

    Sig ownerSig, PubKey owner,
    Ripemd160 receiverPkh, int satoshiAmount0,
    Ripemd160 changePkh, int satoshiAmount1) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    PayloadNFT pl = new PayloadNFT(lockingScript);

    // dataType must be transfer
    require(pl.dataType == PayloadNFT.TRANSFER);

    // 溯源
    SatoTx st = new SatoTx(this.rabinPubKey, txPreimage, preTxOutpointSig, preTxOutpointMsg, preTxOutpointPadding, 0, b'', b'');
    require(st.verifyGenesis(pl.codeWithGenesisPart, SatoTx.disableUtxoInGenesisTx, b''));

    // authorize
    require(hash160(owner) == pl.ownerPkh);
    require(checkSig(ownerSig, owner));

    // 业务操作
    pl.ownerPkh = receiverPkh;
    bytes outputScript0 = pl.dump();
    bytes output0 = Util.buildOutput(outputScript0, satoshiAmount0);

    bytes lockingScript1 = Util.buildPublicKeyHashScript(changePkh);
    bytes output1 = Util.buildOutput(lockingScript1, satoshiAmount1);

    Sha256 hashOutputs = hash256(output0 + output1);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }

  //////////////// A sell
  public function sell(SigHashPreimage txPreimage,
    int preTxOutpointSig, bytes preTxOutpointMsg, bytes preTxOutpointPadding,
    Sig ownerSig, PubKey owner,
    int satoshAmountSell,
    Ripemd160 changePkh, int satoshiAmount) {

    require(satoshAmountSell > 0);

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    PayloadNFT pl = new PayloadNFT(lockingScript);

    // dataType must be transfer
    require(pl.dataType == PayloadNFT.TRANSFER);

    // authorize
    require(hash160(owner) == pl.ownerPkh);
    require(checkSig(ownerSig, owner));

    // 溯源
    SatoTx st = new SatoTx(this.rabinPubKey, txPreimage, preTxOutpointSig, preTxOutpointMsg, preTxOutpointPadding, 0, b'', b'');
    require(st.verifyGenesis(pl.codeWithGenesisPart, SatoTx.disableUtxoInGenesisTx, b''));

    int satoshiBefore = Util.value(txPreimage);

    // 业务操作
    pl.satoshiAmountSell = satoshAmountSell;
    pl.dataType = PayloadNFT.SELL;
    bytes outputScript0 = pl.dump();
    bytes output0 = Util.buildOutput(outputScript0, satoshiBefore);

    bytes outputScript1 = Util.buildPublicKeyHashScript(changePkh);
    bytes output1 = Util.buildOutput(outputScript1, satoshiAmount);

    Sha256 hashOutputs = hash256(output0 + output1);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }

  //////////////// A cancel sell
  public function cancelSell(SigHashPreimage txPreimage,
    int preTxOutpointSig, bytes preTxOutpointMsg, bytes preTxOutpointPadding,
    Sig ownerSig, PubKey owner,
    Ripemd160 changePkh, int satoshiAmount) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    PayloadNFT pl = new PayloadNFT(lockingScript);

    // dataType must be sell
    require(pl.dataType == PayloadNFT.SELL);

    // authorize
    require(hash160(owner) == pl.ownerPkh);
    require(checkSig(ownerSig, owner));

    // 溯源
    SatoTx st = new SatoTx(this.rabinPubKey, txPreimage, preTxOutpointSig, preTxOutpointMsg, preTxOutpointPadding, 0, b'', b'');
    require(st.verifyGenesis(pl.codeWithGenesisPart, SatoTx.disableUtxoInGenesisTx, b''));

    int satoshiBefore = Util.value(txPreimage);

    // 业务操作
    pl.dataType = PayloadNFT.TRANSFER;
    bytes outputScript0 = pl.dump();
    bytes output0 = Util.buildOutput(outputScript0, satoshiBefore);

    bytes outputScript1 = Util.buildPublicKeyHashScript(changePkh);
    bytes output1 = Util.buildOutput(outputScript1, satoshiAmount);

    Sha256 hashOutputs = hash256(output0 + output1);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }

  //////////////// B buy
  public function buy(SigHashPreimage txPreimage,
    int preTxOutpointSig, bytes preTxOutpointMsg, bytes preTxOutpointPadding,
    Ripemd160 buyerPkh, int satoshiAmount0,
    Ripemd160 changePkh, int satoshiAmount1) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    PayloadNFT pl = new PayloadNFT(lockingScript);

    // dataType must be sell
    require(pl.dataType == PayloadNFT.SELL);

    // 溯源
    SatoTx st = new SatoTx(this.rabinPubKey, txPreimage, preTxOutpointSig, preTxOutpointMsg, preTxOutpointPadding, 0, b'', b'');
    require(st.verifyGenesis(pl.codeWithGenesisPart, SatoTx.disableUtxoInGenesisTx, b''));

    int satoshiBefore = Util.value(txPreimage);

    Ripemd160 sellerPkh = pl.ownerPkh;

    // 业务操作
    pl.ownerPkh = buyerPkh;
    pl.dataType = PayloadNFT.TRANSFER;
    bytes outputScript0 = pl.dump();
    bytes output0 = Util.buildOutput(outputScript0, satoshiAmount0);

    bytes outputScript1 = Util.buildPublicKeyHashScript(changePkh);
    bytes output1 = Util.buildOutput(outputScript1, satoshiAmount1);

    bytes outputScript2 = Util.buildPublicKeyHashScript(sellerPkh);
    bytes output2 = Util.buildOutput(outputScript2, pl.satoshiAmountSell + satoshiBefore);

    Sha256 hashOutputs = hash256(output0 + output1 + output2);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }

  //////////////// burn a token back to normal bitcoins
  public function burn(SigHashPreimage txPreimage,
    Sig ownerSig, PubKey owner,
    Ripemd160 receiverPkh, int satoshiAmount) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    PayloadNFT pl = new PayloadNFT(lockingScript);

    // dataType must be transfer
    require(pl.dataType == PayloadNFT.TRANSFER);

    // authorize
    require(hash160(owner) == pl.ownerPkh);
    require(checkSig(ownerSig, owner));

    // send to a P2PKH script
    bytes lockingScript0 = Util.buildPublicKeyHashScript(receiverPkh);
    bytes output0 = Util.buildOutput(lockingScript0, satoshiAmount);
    Sha256 hashOutputs = hash256(output0);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }
}
