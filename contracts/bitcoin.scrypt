import "util.scrypt";
import "rabin.scrypt";
import "satotx.scrypt";

/**
* A token protocol based on UTXO model
*
* locking script:
*
* mint:
*
*   codePart, GenesisPart, blockHeader, blockHeight, MINT
*
* split:
* merge:
*
*   codePart, GenesisPart, ownerPkh, tokenAmount, TRANSFER
*
*
* mint函数允许公开按blockHeight递增发行token，输入为1个MINT，输出为1个MINT，1个TRANSFER
*      发行规则和Bitcoin一致：
*      需要提供blockHeader, 后一个blockHeader中必须包括前一个blockHeader的hash256；
*      满足难度约束； 每次发行量按210000块减半；初始一次为50个，但没有实现交易费。
*
* split函数允许用户分割token，输入为1个TRANSFER，输出为2个TRANSFER。
* merge函数允许用户合并2个token，输入为2个TRANSFER，输出为1个TRANSFER.
*
* burn 函数用于销毁用户的token，输入为1个TRANSFER，输出为1个找零
*/

contract Payload {
  /* base */
  int dataStart;
  bytes codePart;
  bytes dataType;

  /* mint */
  bytes blockHeader;
  int blockHeight;

  /* transfer */
  Ripemd160 ownerPkh;
  int amount;

  /* 溯源需匹配genesisTx input的outpoint 和output的index */
  bytes genesisOutpoint;
  bytes genesisOutputIdx;

  static int mintLen = 88;
  static bytes MINT = b'00';
  static bytes mintPrefix = b'4c58';

  static int transferLen = 29;
  static bytes TRANSFER = b'01';
  static bytes transferPrefix = b'1d';

  constructor(bytes scriptCode) {
    int scriptLen = len(scriptCode);
    this.dataType = scriptCode[scriptLen - 1 : ];

    /* support many kinds of data type */
    if (this.dataType == Payload.MINT) {
      /* part */
      this.dataStart = scriptLen - Payload.mintLen;
      this.codePart = scriptCode[ : this.dataStart - 2];
      /* genesis */
      int codeLen = len(this.codePart);
      this.genesisOutpoint = this.codePart[codeLen - 40 : codeLen - 4];
      this.genesisOutputIdx = this.codePart[codeLen - 4 : ];
      /* data: */
      bytes dataPart = scriptCode[this.dataStart : ];
      this.ownerPkh = Ripemd160(dataPart[ : 20]);
      this.amount = unpack(dataPart[20 : 20 + 8]);
    } else {
      /* part */
      this.dataStart = scriptLen - Payload.transferLen;
      this.codePart = scriptCode[ : this.dataStart - 1];
      /* genesis */
      int codeLen = len(this.codePart);
      this.genesisOutpoint = this.codePart[codeLen - 40 : codeLen - 4];
      this.genesisOutputIdx = this.codePart[codeLen - 4 : ];
      /* data: */
      bytes dataPart = scriptCode[this.dataStart : ];
      this.blockHeader = dataPart[ : 80];
      this.blockHeight = unpack(dataPart[80 : 80 + 8]);
    }
  }

  function dump() : bytes {
    bytes payload = b'';
    if (this.dataType == Payload.MINT) {
      payload = Payload.mintPrefix +
      this.blockHeader + num2bin(this.blockHeight, Util.OutputValueLen) +
      this.dataType;
    } else {
      payload = Payload.transferPrefix +
      this.ownerPkh + num2bin(this.amount, Util.OutputValueLen) +
      this.dataType;
    }
    return this.codePart + payload;
  }
}

contract Bitcoin {
  int rabinPubKey;

  /* mint */
  public function mint(SigHashPreimage txPreimage,
    int preTxOutpointSig, bytes preTxOutpointMsg, bytes preTxOutpointPadding,
    bytes blockHeader,
    Ripemd160 receiverPkh, int satoshiAmount1,
    Ripemd160 changePkh, int satoshiAmount2) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    require(len(blockHeader) == 80);

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    Payload pl = new Payload(lockingScript);

    // dataType must be mint
    require(pl.dataType == Payload.MINT);

    // 溯源
    SatoTx st = new SatoTx(this.rabinPubKey, txPreimage, preTxOutpointSig, preTxOutpointMsg, preTxOutpointPadding, 0, b'', b'');
    require(st.verifyGenesis(pl.codePart, pl.genesisOutpoint, pl.genesisOutputIdx));

    // 计算token subsidy
    int halvings = pl.blockHeight / 210000;
    require(halvings <= 32);
    bytes tokenAmount = num2bin(5000000000, Util.OutputValueLen) << halvings;

    int satoshiMint = Util.value(txPreimage);

    pl.blockHeader = blockHeader;
    pl.blockHeight = pl.blockHeight + 1;
    bytes outputScript0 = pl.dump();
    bytes output0 = Util.buildOutput(outputScript0, satoshiMint);

    pl.ownerPkh = receiverPkh;
    pl.amount = unpack(tokenAmount);
    pl.dataType = Payload.TRANSFER;
    bytes outputScript1 = pl.dump();
    bytes output1 = Util.buildOutput(outputScript1, satoshiAmount1);

    bytes outputScript2 = Util.buildPublicKeyHashScript(changePkh);
    bytes output2 = Util.buildOutput(outputScript2, satoshiAmount2);

    Sha256 hashOutputs = hash256(output0 + output1 + output2);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }

  /* split */
  public function split(SigHashPreimage txPreimage,
    int preTxOutpointSig, bytes preTxOutpointMsg, bytes preTxOutpointPadding,

    Sig senderSig, PubKey sender,
    Ripemd160 receiver0Pkh, int tokenAmount0, int satoshiAmount0,
    Ripemd160 receiver1Pkh, int tokenAmount1, int satoshiAmount1,
    Ripemd160 changePkh, int satoshiAmount2) {

    require(tokenAmount0 > 0);
    require(tokenAmount1 > 0);

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    Payload pl = new Payload(lockingScript);

    // dataType must be transfer
    require(pl.dataType == Payload.TRANSFER);
    // authorize
    require(hash160(sender) == pl.ownerPkh);
    require(checkSig(senderSig, sender));
    require(pl.amount == tokenAmount0 + tokenAmount1);

    // 溯源
    SatoTx st = new SatoTx(this.rabinPubKey, txPreimage, preTxOutpointSig, preTxOutpointMsg, preTxOutpointPadding, 0, b'', b'');
    require(st.verifyGenesis(pl.codePart, SatoTx.disableUtxoInGenesisTx, b''));

    // 业务操作
    pl.ownerPkh = receiver0Pkh;
    pl.amount = tokenAmount0;
    bytes outputScript0 = pl.dump();
    bytes output0 = Util.buildOutput(outputScript0, satoshiAmount0);

    pl.ownerPkh = receiver1Pkh;
    pl.amount = tokenAmount1;
    bytes outputScript1 = pl.dump();
    bytes output1 = Util.buildOutput(outputScript1, satoshiAmount1);

    bytes outputScript2 = Util.buildPublicKeyHashScript(changePkh);
    bytes output2 = Util.buildOutput(outputScript2, satoshiAmount2);

    Sha256 hashOutputs = hash256(output0 + output1 + output2);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }

  /* merge */
  public function merge(SigHashPreimage txPreimage,
    int preTxOutpointSig, bytes preTxOutpointMsg, bytes preTxOutpointPadding,
    int sideTxUtxoSig, bytes sideTxUtxoMsg, bytes sideTxUtxoPadding,

    Sig senderSig, PubKey sender,
    Ripemd160 receiverPkh, bytes prevouts, int satoshiAmount0,
    Ripemd160 changePkh, int satoshiAmount1) {

    // this ensures the preimage is for the current tx
    require(Tx.checkPreimage(txPreimage));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    Payload pl = new Payload(lockingScript);

    // dataType must be transfer
    require(pl.dataType == Payload.TRANSFER);

    // authorize
    require(hash160(sender) == pl.ownerPkh);
    require(checkSig(senderSig, sender));

    // source
    SatoTx st = new SatoTx(this.rabinPubKey, txPreimage, preTxOutpointSig, preTxOutpointMsg, preTxOutpointPadding,
      sideTxUtxoSig, sideTxUtxoMsg, sideTxUtxoPadding);
    require(st.verifyGenesis(pl.codePart, SatoTx.disableUtxoInGenesisTx, b''));
    // side check
    require(st.verifySide(pl.codePart, prevouts));

    Payload plOther = new Payload(sideTxUtxoMsg[44 : ]);
    /* other scriptCode */
    // dataType must be transfer
    require(plOther.dataType == Payload.TRANSFER);

    // merge
    pl.ownerPkh = receiverPkh;
    pl.amount = pl.amount + plOther.amount;
    bytes outputScript0 = pl.dump();
    bytes output0 = Util.buildOutput(outputScript0, satoshiAmount0);

    bytes outputScript1 = Util.buildPublicKeyHashScript(changePkh);
    bytes output1 = Util.buildOutput(outputScript1, satoshiAmount1);

    Sha256 hashOutputs = hash256(output0 + output1);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }

  // burn a token back to normal bitcoins
  public function burn(SigHashPreimage txPreimage,
    Sig senderSig, PubKey sender,
    Ripemd160 receiverPkh, int satoshiAmount) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    Payload pl = new Payload(lockingScript);

    // dataType must be transfer
    require(pl.dataType == Payload.TRANSFER);

    // authorize
    require(hash160(sender) == pl.ownerPkh);
    require(checkSig(senderSig, sender));

    // send to a P2PKH script
    bytes lockingScript0 = Util.buildPublicKeyHashScript(receiverPkh);
    bytes output0 = Util.buildOutput(lockingScript0, satoshiAmount);

    Sha256 hashOutputs = hash256(output0);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }
}
