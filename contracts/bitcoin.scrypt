import "util.scrypt";
import "rabin.scrypt";
import "satotx.scrypt";

/**
 A token protocol based on UTXO model

 locking script:

 mint:

   codePart, GenesisOutpoint, blockHeader, blockHeight, MINT

 split:
 merge:

   codePart, GenesisOutpoint, ownerPkh, tokenAmount, TRANSFER


 mint函数允许公开按blockHeight递增发行token，输入为1个MINT，输出为1个MINT，1个TRANSFER
      发行规则和Bitcoin一致：
      需要提供blockHeader, 后一个blockHeader中必须包括前一个blockHeader的hash256；
      满足难度约束； 每次发行量按210000块减半；初始一次为50个，但没有实现交易费。

 split函数允许用户分割token，输入为1个TRANSFER，输出为2个TRANSFER。
 merge函数允许用户合并2个token，输入为2个TRANSFER，输出为1个TRANSFER.

 burn 函数用于销毁用户的token，输入为1个TRANSFER，输出为1个找零
*/

contract Payload {
  int dataStart;
  bytes codePart;

  bytes genesisOutpoint;
  Ripemd160 ownerPkh;
  int amount;
  bytes action;

  bytes blockHeader;
  int blockHeight;

  /* fixme: use len after op_return */
  static int mintLen = 125;
  static int transferLen = 65;
  static bytes MINT = b'00';
  static bytes TRANSFER = b'01';

  constructor(bytes action, bytes scriptCode) {
    int scriptLen = len(scriptCode);
    if (action == Payload.MINT) {
      this.dataStart = scriptLen - Payload.mintLen;
    } else {
      this.dataStart = scriptLen - Payload.transferLen;
    }
    this.codePart = scriptCode[ : this.dataStart];
    bytes dataPart = scriptCode[this.dataStart : ];

    this.genesisOutpoint = dataPart[ : 36];
    if (action == Payload.MINT) {
      this.ownerPkh = Ripemd160(dataPart[36 : 36 + 20]);
      this.amount = unpack(dataPart[56 : 56 + 8]);
    } else {
      this.blockHeader = dataPart[36 : 36 + 80];
      this.blockHeight = unpack(dataPart[116 : 116 + 8]);
    }
    this.action = dataPart[scriptLen - 1 : ];
  }

  function dump() : bytes {
    bytes payload =(this.genesisOutpoint +
      this.ownerPkh +
      num2bin(this.amount, Util.OutputValueLen) +
      this.action);

    return this.codePart + payload;
  }
}


contract Bitcoin {
  int rabinPubKey;

  /* mint */
  public function mint(SigHashPreimage txPreimage,
    int preTxOutpointSig, bytes preTxOutpointMsg, bytes preTxOutpointPadding,
    bytes blockHeader,
    Ripemd160 receiverPkh, int satoshiAmount1,
    Ripemd160 changePkh, int satoshiAmount2) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    require(len(blockHeader) == 80);

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    Payload pl = new Payload(Payload.MINT, lockingScript);

    // action must be mint
    require(pl.action == Payload.MINT);

    // 溯源
    SatoTx st = new SatoTx(this.rabinPubKey, txPreimage, preTxOutpointSig, preTxOutpointMsg, preTxOutpointPadding, 0, b'', b'');
    require(st.verifyGenesis(lockingScript, pl.genesisOutpoint, pl.dataStart));

    // 计算token subsidy
    int halvings = pl.blockHeight / 210000;
    require(halvings <= 32);
    bytes tokenAmount = num2bin(5000000000, Util.OutputValueLen) << halvings;

    int satoshiMint = Util.value(txPreimage);

    pl.blockHeader = blockHeader;
    pl.blockHeight = pl.blockHeight + 1;
    bytes outputScript0 = pl.dump();
    bytes output0 = Util.buildOutput(outputScript0, satoshiMint);

    pl.ownerPkh = receiverPkh;
    pl.amount = unpack(tokenAmount);
    pl.action = Payload.TRANSFER;
    bytes outputScript1 = pl.dump();
    bytes output1 = Util.buildOutput(outputScript1, satoshiAmount1);

    bytes outputScript2 = Util.buildPublicKeyHashScript(changePkh);
    bytes output2 = Util.buildOutput(outputScript2, satoshiAmount2);

    Sha256 hashOutputs = hash256(output0 + output1 + output2);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }

  /* split */
  public function split(SigHashPreimage txPreimage,
    int preTxOutpointSig, bytes preTxOutpointMsg, bytes preTxOutpointPadding,

    Sig senderSig, PubKey sender,
    Ripemd160 receiver0Pkh, int tokenAmount0, int satoshiAmount0,
    Ripemd160 receiver1Pkh, int tokenAmount1, int satoshiAmount1,
    Ripemd160 changePkh, int satoshiAmount2) {

    require(tokenAmount0 > 0);
    require(tokenAmount1 > 0);

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    Payload pl = new Payload(Payload.TRANSFER, lockingScript);

    // action must be transfer
    require(pl.action == Payload.TRANSFER);

    // 溯源
    SatoTx st = new SatoTx(this.rabinPubKey, txPreimage, preTxOutpointSig, preTxOutpointMsg, preTxOutpointPadding, 0, b'', b'');
    require(st.verifyGenesis(lockingScript, SatoTx.disableUtxoInGenesisTx, pl.dataStart));

    // 业务操作
    // authorize
    require(hash160(sender) == pl.ownerPkh);
    require(checkSig(senderSig, sender));

    // split
    require(pl.amount == tokenAmount0 + tokenAmount1);

    // setting first balance as 0 is just a convention, not a requirement
    pl.ownerPkh = receiver0Pkh;
    pl.amount = tokenAmount0;
    bytes outputScript0 = pl.dump();
    bytes output0 = Util.buildOutput(outputScript0, satoshiAmount0);

    pl.ownerPkh = receiver1Pkh;
    pl.amount = tokenAmount1;
    bytes outputScript1 = pl.dump();
    bytes output1 = Util.buildOutput(outputScript1, satoshiAmount1);

    bytes outputScript2 = Util.buildPublicKeyHashScript(changePkh);
    bytes output2 = Util.buildOutput(outputScript2, satoshiAmount2);

    Sha256 hashOutputs = hash256(output0 + output1 + output2);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }

  /* merge */
  public function merge(SigHashPreimage txPreimage,
    int preTxOutpointSig, bytes preTxOutpointMsg, bytes preTxOutpointPadding,
    int sideTxUtxoSig, bytes sideTxUtxoMsg, bytes sideTxUtxoPadding,

    Sig senderSig, PubKey sender,
    Ripemd160 receiverPkh, bytes prevouts, int satoshiAmount0,
    Ripemd160 changePkh, int satoshiAmount1) {

    // this ensures the preimage is for the current tx
    require(Tx.checkPreimage(txPreimage));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    Payload pl = new Payload(Payload.TRANSFER, lockingScript);

    // action must be transfer
    require(pl.action == Payload.TRANSFER);

    SatoTx st = new SatoTx(this.rabinPubKey, txPreimage, preTxOutpointSig, preTxOutpointMsg, preTxOutpointPadding,
      sideTxUtxoSig, sideTxUtxoMsg, sideTxUtxoPadding);
    // 溯源
    require(st.verifyGenesis(lockingScript, SatoTx.disableUtxoInGenesisTx, pl.dataStart));
    // 排查
    require(st.verifySide(lockingScript, prevouts, pl.dataStart));

    int otherTokenAmount = unpack(sideTxUtxoMsg[44 + pl.dataStart + 32 + 4 + Util.PubKeyHashLen : 44 + pl.dataStart + 32 + 4 + Util.PubKeyHashLen + 8]);

    // 业务操作
    // authorize
    require(hash160(sender) == pl.ownerPkh);
    require(checkSig(senderSig, sender));

    // merge
    pl.ownerPkh = receiverPkh;
    pl.amount = pl.amount + otherTokenAmount;
    bytes outputScript0 = pl.dump();
    bytes output0 = Util.buildOutput(outputScript0, satoshiAmount0);

    bytes outputScript1 = Util.buildPublicKeyHashScript(changePkh);
    bytes output1 = Util.buildOutput(outputScript1, satoshiAmount1);

    Sha256 hashOutputs = hash256(output0 + output1);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }

  // burn a token back to normal bitcoins
  public function burn(SigHashPreimage txPreimage,
    Sig senderSig, PubKey sender,
    Ripemd160 receiverPkh, int satoshiAmount) {

    SigHashType sigHashType = SigHash.ANYONECANPAY | SigHash.ALL | SigHash.FORKID;
    // this ensures the preimage is for the current tx
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    // read previous locking script
    bytes lockingScript = Util.scriptCode(txPreimage);
    Payload pl = new Payload(Payload.TRANSFER, lockingScript);

    // action must be transfer
    require(pl.action == Payload.TRANSFER);

    // authorize
    require(hash160(sender) == pl.ownerPkh);
    require(checkSig(senderSig, sender));

    // send to a P2PKH script
    bytes lockingScript0 = Util.buildPublicKeyHashScript(receiverPkh);
    bytes output0 = Util.buildOutput(lockingScript0, satoshiAmount);

    Sha256 hashOutputs = hash256(output0);
    require(hashOutputs == Util.hashOutputs(txPreimage));
  }
}
