import "util.scrypt";

contract SatoTx {
  int rabinPubKey;
  SigHashPreimage txPreimage;
  int preTxOutpointSig;
  bytes preTxOutpointMsg;
  bytes preTxOutpointPadding;

  int sideTxUtxoSig;
  bytes sideTxUtxoMsg;
  bytes sideTxUtxoPadding;

  static bytes disableUtxoInGenesisTx = b'64697361626c654f687465725574786f4d6f76696e6746726f6d47656e65736973547821';

  /* 溯源
   * 查看生成当前花费的utxo 的Tx内，是否有和当前脚本一致的锁定脚本。
   * 或者有Genesis Utxo
   */
  public function verifyGenesis(bytes codeWithGenesisPart, bytes genesisOutpoint, bytes genesisOutputIdx) {
    /* 76 = 32 + 32 + 4 + 8 */
    int scriptOffset = 76;

    // preTxOutpointMsg: txId, preTxId+index, value, lockingScript
    require(len(this.preTxOutpointMsg) > scriptOffset);

    //  签名校验preTx的outpoint
    RabinSignature rb = new RabinSignature();
    require(rb.verifySig(this.preTxOutpointSig, this.preTxOutpointMsg, this.preTxOutpointPadding, this.rabinPubKey));

    // 必须是本合约的preTx
    bytes thisOutpoint = Util.outpoint(this.txPreimage);
    require(thisOutpoint[ : 32] == this.preTxOutpointMsg[ : 32]);

    // transfer不检查是否匹配GenesisTx第一个outpoint
    // mint 需要检查是否匹配GenesisTx第一个outpoint

    bool matchGenesis = false;
    bytes preOutpoint = this.preTxOutpointMsg[32 : 32 + 36];
    if (preOutpoint == genesisOutpoint) {
      matchGenesis = true;
      // output输出index必须匹配 genesisOutputIdx
      require(thisOutpoint[32 : 36] == genesisOutputIdx);
    } else {
      //必须包含codeWithGenesisPart
      int scriptCodeLen = len(codeWithGenesisPart);
      require(len(this.preTxOutpointMsg) > scriptOffset + scriptCodeLen);
      if (this.preTxOutpointMsg[scriptOffset : scriptOffset + scriptCodeLen] == codeWithGenesisPart) {
        matchGenesis = true;
      }
    }
    // 溯源检查
    require(matchGenesis == true);
  }

  /* 查看当前Tx其他某输入的锁定脚本（参数：codePart），是否和正在执行的锁定脚本一致
   * 1. 输入参数必须为当前Tx的非正在执行的utxo
   * 2. 锁定脚本必须一致
   */
  public function verifySide(bytes codePart, bytes prevouts) {
    /* 44 = 32 + 4 + 8 */
    int scriptOffset = 44;

    // this ensures prevouts is the preimage of hashPrevouts
    require(hash256(prevouts) == Util.hashPrevouts(this.txPreimage));

    // sideTxUtxoMsg: txId+index, value, lockingScript
    require(len(this.sideTxUtxoMsg) > scriptOffset);

    /*  检查side outpoint script + value rabin签名 */
    RabinSignature rb = new RabinSignature();
    require(rb.verifySig(this.sideTxUtxoSig, this.sideTxUtxoMsg, this.sideTxUtxoPadding, this.rabinPubKey));

    // 不可以是当前输出
    bytes thisOutpoint = Util.outpoint(this.txPreimage);
    require(thisOutpoint != this.sideTxUtxoMsg[ : 36]);

    // each outpoint: 32 byte txid + 4 byte index
    int prevOutpointsCount = len(prevouts) / 36;
    require(prevOutpointsCount <= 5);

    bool matchSide = false;
    int currentI = 0;
    int sideI = 0;
    int i = 0;
    loop (5) {
      if (i < prevOutpointsCount && matchSide == false) {
        bytes outpoint = prevouts[i * 36 : i * 36 + 36];

        if (outpoint == thisOutpoint) {
          currentI = i;
          /* 记录当前loop i */
        }
        else if (outpoint == this.sideTxUtxoMsg[ : 36]) {
          sideI = i;
          int scriptCodeLen = len(codePart);
          if (scriptCodeLen > 0) {
              // 必须是同类合约
              require(len(this.sideTxUtxoMsg) > scriptOffset + scriptCodeLen);
              if (this.sideTxUtxoMsg[scriptOffset : scriptOffset + scriptCodeLen] == codePart) {
                  matchSide = true;
              }
          } else {
              // 忽视合约类型，只检查是否是当前utxo
              matchSide = true;
          }
        }
        i = i + 1;
      }
    }
    // Side检查
    require(matchSide == true);
  }
}
