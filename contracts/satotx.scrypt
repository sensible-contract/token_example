import "util.scrypt";

contract SatoTx {
  int rabinPubKey;
  SigHashPreimage txPreimage;
  int preTxOutpointSig;
  bytes preTxOutpointMsg;
  bytes preTxOutpointPadding;

  int sideTxUtxoSig;
  bytes sideTxUtxoMsg;
  bytes sideTxUtxoPadding;

  static bytes disableUtxoInGenesisTx = b'64697361626c654f687465725574786f4d6f76696e6746726f6d47656e65736973547821';

  /* 溯源 */
  public function verifyGenesis(bytes scriptCodePart, bytes genesisOutpoint, bytes genesisOutputIdx) {
    /* 76 = 32 + 32 + 4 + 8 */
    int scriptOffset = 76;

    // preTxOutpointMsg: txId, preTxId+index, value, lockingScript
    require(len(this.preTxOutpointMsg) > scriptOffset);

    //  签名校验preTx的outpoint
    RabinSignature rb = new RabinSignature();
    require(rb.verifySig(this.preTxOutpointSig, this.preTxOutpointMsg, this.preTxOutpointPadding, this.rabinPubKey));

    // 必须是本合约的preTx
    bytes thisOutpoint = Util.outpoint(this.txPreimage);
    require(thisOutpoint[ : 32] == this.preTxOutpointMsg[ : 32]);

    // transfer不检查是否匹配GenesisTx第一个outpoint
    // mint 需要检查是否匹配GenesisTx第一个outpoint

    bool matchGenesis = false;
    bytes preOutpoint = this.preTxOutpointMsg[32 : 32 + 36];
    if (preOutpoint == genesisOutpoint) {
      matchGenesis = true;
      // output输出index必须匹配 genesisOutputIdx
      require(thisOutpoint[32 : 36] == genesisOutputIdx);
    } else {
      //必须包含scriptCodePart
      int scriptCodeLen = len(scriptCodePart);
      require(len(this.preTxOutpointMsg) > scriptOffset + scriptCodeLen);
      if (this.preTxOutpointMsg[scriptOffset : scriptOffset + scriptCodeLen] == scriptCodePart) {
        matchGenesis = true;
      }
    }
    // 溯源检查
    require(matchGenesis == true);
  }

  /* 并排 */
  public function verifySide(bytes scriptCodePart, bytes prevouts) {
    /* 44 = 32 + 4 + 8 */
    int scriptOffset = 44;

    // this ensures prevouts is the preimage of hashPrevouts
    require(hash256(prevouts) == Util.hashPrevouts(this.txPreimage));

    // sideTxUtxoMsg: txId+index, value, lockingScript
    require(len(this.sideTxUtxoMsg) > scriptOffset);

    /*  检查side outpoint script + value rabin签名 */
    RabinSignature rb = new RabinSignature();
    require(rb.verifySig(this.sideTxUtxoSig, this.sideTxUtxoMsg, this.sideTxUtxoPadding, this.rabinPubKey));

    // 不可以是当前输出
    bytes thisOutpoint = Util.outpoint(this.txPreimage);
    require(thisOutpoint != this.sideTxUtxoMsg[ : 36]);

    // each outpoint: 32 byte txid + 4 byte index
    int prevOutpointsCount = len(prevouts) / 36;
    require(prevOutpointsCount <= 5);

    bool matchSide = false;
    int currentI = 0;
    int sideI = 0;
    int i = 0;
    loop (5) {
      if (i < prevOutpointsCount && matchSide == false) {
        bytes outpoint = prevouts[i * 36 : i * 36 + 36];

        if (outpoint == thisOutpoint) {
          currentI = i;
          /* 记录当前loop i */

        }
        else if (outpoint == this.sideTxUtxoMsg[ : 36]) {
          sideI = i;
          // 必须是同类合约
          int scriptCodeLen = len(scriptCodePart);
          require(len(this.sideTxUtxoMsg) > scriptOffset + scriptCodeLen);
          if (this.sideTxUtxoMsg[scriptOffset : scriptOffset + scriptCodeLen] == scriptCodePart) {
            matchSide = true;
          }
        }
        i = i + 1;
      }
    }
    // Side检查
    require(matchSide == true);
  }

}
